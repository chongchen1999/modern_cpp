# Bitset

C++ 中的 `bitset` 是一个固定大小的位序列容器，用于高效地处理二进制位操作。它位于 `<bitset>` 头文件中，提供了一系列方法直接操作位，适合需要位级操作的场景（如位掩码、状态标志、位集合运算等）。

---

**核心特性**
1. 固定大小：在编译时确定大小（通过模板参数指定），例如 `bitset<8>` 表示 8 位的集合。
2. 高效存储：每个位仅占用 1 bit 内存（相比 `bool` 数组更节省空间）。
3. 支持位运算：直接重载了 `&`、`|`、`^`、`~`、`<<`、`>>` 等运算符。
4. 丰富的操作：支持位设置、重置、翻转、计数等。

---

**基本用法**
1. 初始化
```cpp
#include <bitset>
#include <iostream>

int main() {
    // 默认初始化（所有位为 0）
    std::bitset<8> b1; // 00000000

    // 从整数初始化
    std::bitset<8> b2(42); // 00101010

    // 从字符串初始化（"1010" -> 00001010）
    std::bitset<8> b3("1010"); // 从右向左解析

    std::cout << b1 << "\n" << b2 << "\n" << b3 << std::endl;
}
```

2. 访问与修改
```cpp
std::bitset<4> bs("1010");

// 访问位（从右到左索引为 0~n-1）
bool bit0 = bs[0]; // 0（最右侧位）
bool bit2 = bs[2]; // 1

// 修改位
bs.set(1);    // 将第1位设为1: 1010 -> 1110
bs.reset(3);  // 将第3位设为0: 1110 -> 0110
bs.flip(0);   // 翻转第0位: 0110 -> 0111

// 全部操作
bs.set();     // 所有位置1: 1111
bs.reset();   // 所有位置0: 0000
bs.flip();    // 所有位取反
```

3. 位运算
```cpp
std::bitset<4> a("1100");
std::bitset<4> b("1010");

auto c = a & b; // 位与: 1000
auto d = a | b; // 位或: 1110
auto e = a ^ b; // 位异或: 0110
auto f = ~a;    // 位取反: 0011
auto g = a << 1; // 左移: 1000
```

4. 常用方法
```cpp
std::bitset<8> bs("11001010");

// 统计1的个数
size_t count = bs.count(); // 4

// 总位数
size_t size = bs.size();   // 8

// 检查是否有1
bool any = bs.any();       // true
bool none = bs.none();     // false

// 转换为其他类型
unsigned long ul = bs.to_ulong();
std::string s = bs.to_string(); // "11001010"
```

---

**应用场景**
1. 状态压缩：用少量位表示多个布尔状态（如权限标志）。
2. 位掩码：快速检查或设置特定位。
3. 集合运算：表示集合的并、交、补运算（每个位代表一个元素是否存在）。
4. 性能优化：替代 `bool` 数组减少内存占用。

---

**注意事项**
• 大小固定：无法动态调整，需在编译时确定。

• 越界风险：访问不存在的位（如 `bs[10]`）可能导致未定义行为。

• 字符串解析：`bitset("1010")` 从右向左解析（索引0是最低位）。


---

**示例：统计二进制中1的个数**
```cpp
#include <bitset>
#include <iostream>

int main() {
    std::bitset<32> num(12345); // 32位二进制表示
    std::cout << "Number of 1s: " << num.count() << std::endl;
    return 0;
}
```

`bitset` 是 C++ 中处理位级操作的高效工具，尤其适合需要紧凑存储和快速位运算的场景。